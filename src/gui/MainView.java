/*********************************************************************
 *
 *  TodoListManager - Open-source manager of todo lists
 *
 *  Copyright (C) 2019
 *
 *  This file is part of TodoListManager.
 *
 *  TodoListManager is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  TodoListManager is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with Treeler.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Contact: Lluís Alemany Puig (lluis.alemany.puig@gmail.com)
 *
 ********************************************************************/

package gui;

import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.logging.Level;
import javax.swing.Box;
import javax.swing.GroupLayout;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.Timer;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.JToolBar;
import javax.swing.JTree;
import javax.swing.LayoutStyle;
import javax.swing.SwingConstants;
import javax.swing.WindowConstants;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.TreeSelectionModel;

import todomanager.task.*;
import todomanager.util.Logger;
import todomanager.util.SystemInfo;
import todomanager.util.Tools;

/**
 * @brief Main class: the only file that defines the Graphical User Interface.
 * @author Lluís Alemany Puig
 */
public class MainView extends javax.swing.JFrame {

	private final DefaultTreeModel treeModel;
	private final DefaultMutableTreeNode highPriorNode;
	private final DefaultMutableTreeNode medPriorNode;
	private final DefaultMutableTreeNode lowPriorNode;
	private final Logger log;
	private boolean changesSaved;
	private String authorName;
	
	private String lockFileName = null;
	private File lockFile = null;
	
	public MainView() {
		log = Logger.getInstance();
		SystemInfo sysinfo = SystemInfo.getInstance();
		
		log.begin();
		log.info("Program executed from path: " + sysinfo.userDir);
		log.info("System information:");
		log.info("    Language: " + sysinfo.langRaw);
		log.info("    User Directory: " + sysinfo.userDir);
		log.info("    Operative System: " + sysinfo.OS);
		
		initComponents();
		
		treeModel = (DefaultTreeModel) (treeTasks.getModel());
		DefaultMutableTreeNode root = (DefaultMutableTreeNode) treeModel.getRoot();
		highPriorNode = (DefaultMutableTreeNode) root.getChildAt(0);
		medPriorNode = (DefaultMutableTreeNode) root.getChildAt(1);
		lowPriorNode = (DefaultMutableTreeNode) root.getChildAt(2);
		
		treeTasks.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
		
		CustomTreeCellRenderer renderer = new CustomTreeCellRenderer(14);
		treeTasks.setCellRenderer(renderer);
		
		setChangesSaved();
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel3 = new JPanel();
        jScrollPane6 = new JScrollPane();
        treeTasks = new JTree();
        jPanel2 = new JPanel();
        buttonRemoveTask = new JButton();
        buttonNewTask = new JButton();
        buttonTaskDown = new JButton();
        buttonTaskUp = new JButton();
        buttonIncrPriority = new JButton();
        buttonDecrPriority = new JButton();
        buttonExpandAll = new JButton();
        buttonContractAll = new JButton();
        textBoxError = new JTextField();
        jPanel7 = new JPanel();
        jPanel5 = new JPanel();
        buttonTaskWorking = new JButton();
        buttonTaskCancel = new JButton();
        buttonTaskDone = new JButton();
        buttonTaskDelete = new JButton();
        buttonTaskOnRevision = new JButton();
        buttonTaskHold = new JButton();
        buttonTaskPendingRevision = new JButton();
        buttonEditTask = new JButton();
        buttonClear = new JButton();
        jPanel1 = new JPanel();
        labelTaskState = new JLabel();
        textBoxTaskDate = new JTextField();
        labelTaskID = new JLabel();
        textBoxTaskName = new JTextField();
        jLabel1 = new JLabel();
        jLabel2 = new JLabel();
        jScrollPane1 = new JScrollPane();
        textAreaTaskChanges = new JTextArea();
        jLabel3 = new JLabel();
        jLabel6 = new JLabel();
        jScrollPane7 = new JScrollPane();
        textAreaTaskDescription = new JTextArea();
        jLabel4 = new JLabel();
        textBoxTaskAuthor = new JTextField();
        jLabel5 = new JLabel();
        jLabel7 = new JLabel();
        jToolBar1 = new JToolBar();
        buttonOpenTasks = new JButton();
        buttonOverwriteTasks = new JButton();
        buttonSaveTasksAs = new JButton();
        jSeparator2 = new JToolBar.Separator();
        buttonSetAuthor = new JButton();
        filler1 = new Box.Filler(new Dimension(10, 0), new Dimension(10, 0), new Dimension(10, 32767));
        labelAuthor = new JLabel();
        jSeparator3 = new JToolBar.Separator();
        labelUnsavedChanges = new JLabel();
        jMenuBar1 = new JMenuBar();
        jMenu1 = new JMenu();
        menuItem1_OpenFile = new JMenuItem();
        menuItem1_OverWriteTasks = new JMenuItem();
        menuItem1_SaveTasksAs = new JMenuItem();
        jSeparator1 = new JPopupMenu.Separator();
        menuItem1_Exit = new JMenuItem();
        jMenu2 = new JMenu();
        menuItem2_About = new JMenuItem();

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setTitle("Todo List Manager");
        addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        DefaultMutableTreeNode treeNode1 = new DefaultMutableTreeNode("Tasks");
        DefaultMutableTreeNode treeNode2 = new DefaultMutableTreeNode("High Priority");
        treeNode1.add(treeNode2);
        treeNode2 = new DefaultMutableTreeNode("Medium Priority");
        treeNode1.add(treeNode2);
        treeNode2 = new DefaultMutableTreeNode("Low Priority");
        treeNode1.add(treeNode2);
        treeTasks.setModel(new DefaultTreeModel(treeNode1));
        treeTasks.setRootVisible(false);
        treeTasks.addTreeSelectionListener(new TreeSelectionListener() {
            public void valueChanged(TreeSelectionEvent evt) {
                treeTasksValueChanged(evt);
            }
        });
        jScrollPane6.setViewportView(treeTasks);

        buttonRemoveTask.setText("Remove");
        buttonRemoveTask.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonRemoveTaskMouseClicked(evt);
            }
        });

        buttonNewTask.setText("New Task");
        buttonNewTask.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonNewTaskMouseClicked(evt);
            }
        });

        buttonTaskDown.setText("Down");
        buttonTaskDown.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonTaskDownMouseClicked(evt);
            }
        });

        buttonTaskUp.setText("Up");
        buttonTaskUp.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonTaskUpMouseClicked(evt);
            }
        });

        buttonIncrPriority.setText("+ Priority");
        buttonIncrPriority.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonIncrPriorityMouseClicked(evt);
            }
        });

        buttonDecrPriority.setText("- Priority");
        buttonDecrPriority.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonDecrPriorityMouseClicked(evt);
            }
        });

        buttonExpandAll.setText("Show all");
        buttonExpandAll.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonExpandAllMouseClicked(evt);
            }
        });

        buttonContractAll.setText("Hide all");
        buttonContractAll.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonContractAllMouseClicked(evt);
            }
        });

        GroupLayout jPanel2Layout = new GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(jPanel2Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(GroupLayout.Alignment.TRAILING, false)
                    .addComponent(buttonNewTask, GroupLayout.DEFAULT_SIZE, 90, Short.MAX_VALUE)
                    .addComponent(buttonRemoveTask, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                    .addComponent(buttonTaskUp, GroupLayout.PREFERRED_SIZE, 90, GroupLayout.PREFERRED_SIZE)
                    .addComponent(buttonTaskDown, GroupLayout.PREFERRED_SIZE, 90, GroupLayout.PREFERRED_SIZE))
                .addGap(6, 6, 6)
                .addGroup(jPanel2Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(buttonDecrPriority, GroupLayout.PREFERRED_SIZE, 90, GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(buttonContractAll, GroupLayout.PREFERRED_SIZE, 90, GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(buttonIncrPriority, GroupLayout.PREFERRED_SIZE, 90, GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(buttonExpandAll, GroupLayout.PREFERRED_SIZE, 90, GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(jPanel2Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addGroup(GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel2Layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(buttonNewTask)
                    .addComponent(buttonIncrPriority)
                    .addComponent(buttonTaskUp)
                    .addComponent(buttonExpandAll))
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(buttonTaskDown)
                    .addComponent(buttonDecrPriority)
                    .addComponent(buttonRemoveTask)
                    .addComponent(buttonContractAll))
                .addContainerGap())
        );

        GroupLayout jPanel3Layout = new GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(jPanel3Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane6)
                    .addComponent(jPanel2, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(jPanel3Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane6, GroupLayout.PREFERRED_SIZE, 655, GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel2, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        buttonTaskWorking.setText("Working");
        buttonTaskWorking.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonTaskWorkingMouseClicked(evt);
            }
        });

        buttonTaskCancel.setText("Cancel");
        buttonTaskCancel.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonTaskCancelMouseClicked(evt);
            }
        });

        buttonTaskDone.setText("Done");
        buttonTaskDone.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonTaskDoneMouseClicked(evt);
            }
        });

        buttonTaskDelete.setText("Delete");
        buttonTaskDelete.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonTaskDeleteMouseClicked(evt);
            }
        });

        buttonTaskOnRevision.setText("On revision");
        buttonTaskOnRevision.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonTaskOnRevisionMouseClicked(evt);
            }
        });

        buttonTaskHold.setText("Put on Hold");
        buttonTaskHold.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonTaskHoldMouseClicked(evt);
            }
        });

        buttonTaskPendingRevision.setText("Pending revision");
        buttonTaskPendingRevision.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonTaskPendingRevisionMouseClicked(evt);
            }
        });

        buttonEditTask.setText("Edit Task");
        buttonEditTask.setEnabled(false);
        buttonEditTask.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonEditTaskMouseClicked(evt);
            }
        });

        buttonClear.setText("Clear");
        buttonClear.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonClearMouseClicked(evt);
            }
        });

        GroupLayout jPanel5Layout = new GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(jPanel5Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addGroup(GroupLayout.Alignment.TRAILING, jPanel5Layout.createSequentialGroup()
                .addContainerGap(122, Short.MAX_VALUE)
                .addGroup(jPanel5Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                    .addComponent(buttonTaskWorking, GroupLayout.Alignment.TRAILING, GroupLayout.PREFERRED_SIZE, 130, GroupLayout.PREFERRED_SIZE)
                    .addComponent(buttonTaskDone, GroupLayout.Alignment.TRAILING, GroupLayout.PREFERRED_SIZE, 130, GroupLayout.PREFERRED_SIZE)
                    .addComponent(buttonTaskHold, GroupLayout.Alignment.TRAILING, GroupLayout.PREFERRED_SIZE, 130, GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel5Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                    .addComponent(buttonTaskPendingRevision, GroupLayout.Alignment.TRAILING, GroupLayout.PREFERRED_SIZE, 130, GroupLayout.PREFERRED_SIZE)
                    .addComponent(buttonTaskOnRevision, GroupLayout.Alignment.TRAILING, GroupLayout.PREFERRED_SIZE, 130, GroupLayout.PREFERRED_SIZE)
                    .addComponent(buttonEditTask, GroupLayout.Alignment.TRAILING, GroupLayout.PREFERRED_SIZE, 130, GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel5Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                    .addComponent(buttonTaskCancel, GroupLayout.Alignment.TRAILING, GroupLayout.PREFERRED_SIZE, 130, GroupLayout.PREFERRED_SIZE)
                    .addComponent(buttonTaskDelete, GroupLayout.Alignment.TRAILING, GroupLayout.PREFERRED_SIZE, 130, GroupLayout.PREFERRED_SIZE)
                    .addComponent(buttonClear, GroupLayout.Alignment.TRAILING, GroupLayout.PREFERRED_SIZE, 130, GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );
        jPanel5Layout.setVerticalGroup(jPanel5Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel5Layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(buttonTaskDone)
                    .addComponent(buttonTaskOnRevision)
                    .addComponent(buttonTaskCancel))
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel5Layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(buttonTaskPendingRevision)
                    .addComponent(buttonTaskDelete)
                    .addComponent(buttonTaskWorking))
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel5Layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(buttonTaskHold)
                    .addComponent(buttonEditTask)
                    .addComponent(buttonClear))
                .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        labelTaskState.setHorizontalAlignment(SwingConstants.CENTER);
        labelTaskState.setText("-");

        textBoxTaskDate.setEditable(false);

        labelTaskID.setHorizontalAlignment(SwingConstants.CENTER);
        labelTaskID.setText("000000");

        textBoxTaskName.setEditable(false);

        jLabel1.setText("Name");

        jLabel2.setText("Date");

        textAreaTaskChanges.setEditable(false);
        textAreaTaskChanges.setColumns(20);
        textAreaTaskChanges.setLineWrap(true);
        textAreaTaskChanges.setRows(5);
        jScrollPane1.setViewportView(textAreaTaskChanges);

        jLabel3.setText("Description");

        jLabel6.setText("id:");

        textAreaTaskDescription.setEditable(false);
        textAreaTaskDescription.setColumns(20);
        textAreaTaskDescription.setLineWrap(true);
        textAreaTaskDescription.setRows(8);
        textAreaTaskDescription.setTabSize(4);
        jScrollPane7.setViewportView(textAreaTaskDescription);

        jLabel4.setText("History");

        textBoxTaskAuthor.setEditable(false);

        jLabel5.setText("Author");

        jLabel7.setText("State:");

        GroupLayout jPanel1Layout = new GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel3)
                    .addComponent(jLabel4)
                    .addComponent(jLabel2)
                    .addComponent(jLabel1)
                    .addComponent(jLabel5))
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, GroupLayout.DEFAULT_SIZE, 440, Short.MAX_VALUE)
                    .addComponent(jScrollPane7, GroupLayout.Alignment.TRAILING)
                    .addComponent(textBoxTaskName)
                    .addGroup(GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                            .addComponent(textBoxTaskDate)
                            .addComponent(textBoxTaskAuthor))
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel6, GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel7, GroupLayout.Alignment.TRAILING))
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING, false)
                            .addComponent(labelTaskID, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(labelTaskState, GroupLayout.DEFAULT_SIZE, 85, Short.MAX_VALUE))))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(textBoxTaskName, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(textBoxTaskAuthor, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel5)
                    .addComponent(labelTaskID)
                    .addComponent(jLabel6))
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(textBoxTaskDate, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2)
                    .addComponent(jLabel7)
                    .addComponent(labelTaskState, GroupLayout.PREFERRED_SIZE, 26, GroupLayout.PREFERRED_SIZE))
                .addGap(9, 9, 9)
                .addGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane7, GroupLayout.DEFAULT_SIZE, 186, Short.MAX_VALUE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel4)
                    .addComponent(jScrollPane1, GroupLayout.PREFERRED_SIZE, 302, GroupLayout.PREFERRED_SIZE)))
        );

        GroupLayout jPanel7Layout = new GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(jPanel7Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addComponent(jPanel5, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel7Layout.setVerticalGroup(jPanel7Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel5, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        jToolBar1.setFloatable(false);

        buttonOpenTasks.setText("Open");
        buttonOpenTasks.setFocusable(false);
        buttonOpenTasks.setHorizontalTextPosition(SwingConstants.CENTER);
        buttonOpenTasks.setVerticalTextPosition(SwingConstants.BOTTOM);
        buttonOpenTasks.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonOpenTasksMouseClicked(evt);
            }
        });
        jToolBar1.add(buttonOpenTasks);

        buttonOverwriteTasks.setText("Save");
        buttonOverwriteTasks.setEnabled(false);
        buttonOverwriteTasks.setFocusable(false);
        buttonOverwriteTasks.setHorizontalTextPosition(SwingConstants.CENTER);
        buttonOverwriteTasks.setVerticalTextPosition(SwingConstants.BOTTOM);
        buttonOverwriteTasks.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonOverwriteTasksMouseClicked(evt);
            }
        });
        jToolBar1.add(buttonOverwriteTasks);

        buttonSaveTasksAs.setText("Save As");
        buttonSaveTasksAs.setFocusable(false);
        buttonSaveTasksAs.setHorizontalTextPosition(SwingConstants.CENTER);
        buttonSaveTasksAs.setVerticalTextPosition(SwingConstants.BOTTOM);
        buttonSaveTasksAs.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonSaveTasksAsMouseClicked(evt);
            }
        });
        jToolBar1.add(buttonSaveTasksAs);
        jToolBar1.add(jSeparator2);

        buttonSetAuthor.setText("Set author");
        buttonSetAuthor.setFocusable(false);
        buttonSetAuthor.setHorizontalTextPosition(SwingConstants.CENTER);
        buttonSetAuthor.setVerticalTextPosition(SwingConstants.BOTTOM);
        buttonSetAuthor.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                buttonSetAuthorMouseClicked(evt);
            }
        });
        jToolBar1.add(buttonSetAuthor);
        jToolBar1.add(filler1);

        labelAuthor.setText("Unkown author");
        jToolBar1.add(labelAuthor);
        jToolBar1.add(jSeparator3);

        labelUnsavedChanges.setText("There are unsaved changes");
        labelUnsavedChanges.setEnabled(false);
        jToolBar1.add(labelUnsavedChanges);

        jMenu1.setText("File");

        menuItem1_OpenFile.setText("Open");
        menuItem1_OpenFile.addMouseListener(new MouseAdapter() {
            public void mousePressed(MouseEvent evt) {
                menuItem1_OpenFileMousePressed(evt);
            }
        });
        jMenu1.add(menuItem1_OpenFile);

        menuItem1_OverWriteTasks.setText("Save");
        menuItem1_OverWriteTasks.setEnabled(false);
        menuItem1_OverWriteTasks.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                menuItem1_OverWriteTasksMouseClicked(evt);
            }
        });
        jMenu1.add(menuItem1_OverWriteTasks);

        menuItem1_SaveTasksAs.setText("Save As");
        menuItem1_SaveTasksAs.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                menuItem1_SaveTasksAsMouseClicked(evt);
            }
        });
        jMenu1.add(menuItem1_SaveTasksAs);
        jMenu1.add(jSeparator1);

        menuItem1_Exit.setText("Exit");
        menuItem1_Exit.addMouseListener(new MouseAdapter() {
            public void mousePressed(MouseEvent evt) {
                menuItem1_ExitMousePressed(evt);
            }
        });
        jMenu1.add(menuItem1_Exit);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Help");

        menuItem2_About.setText("About");
        menuItem2_About.addMouseListener(new MouseAdapter() {
            public void mousePressed(MouseEvent evt) {
                menuItem2_AboutMousePressed(evt);
            }
        });
        jMenu2.add(menuItem2_About);

        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        GroupLayout layout = new GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                    .addComponent(jToolBar1, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(textBoxError)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanel3, GroupLayout.PREFERRED_SIZE, 419, GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel7, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jToolBar1, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel7, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel3, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(textBoxError, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

	private void openLockFile(String basefile) {
		lockFileName = Tools.getLockFileName(basefile);
		
		log.info("Create a new lock file '" + lockFileName + "'");
		
		// open the lock file
		lockFile = new File(lockFileName);
		FileWriter fw;
		try {
			lockFile.createNewFile();
			fw = new FileWriter(lockFile, false);
			fw.write("Lock file for tasks file '" + basefile + "'.");
			fw.write("Created on " + Tools.getPrettyDate() + ".");
			fw.flush();
		}
		catch (IOException ex) {
			ex.printStackTrace();
			java.util.logging.Logger.getLogger(Logger.class.getName()).log(Level.SEVERE, null, ex);
		}
	}
	
	private void deleteLockFile() {
		if (lockFile != null) {
			log.info("Delete lock file '" + lockFileName + "'");
			lockFile.delete();
		}
	}
	
	private void setNodeExpandedState(DefaultMutableTreeNode node, boolean expanded) {
		ArrayList<DefaultMutableTreeNode> list = Collections.list(node.children());
		for (DefaultMutableTreeNode treeNode : list) {
			setNodeExpandedState(treeNode, expanded);
		}
		if (!expanded && node.isRoot()) {
			return;
		}
		TreePath path = new TreePath(node.getPath());
		if (expanded) {
			treeTasks.expandPath(path);
		}
		else {
			treeTasks.collapsePath(path);
		}
	}
	
	private void setTreeExpandedState(boolean expanded) {
		DefaultMutableTreeNode node = (DefaultMutableTreeNode) treeTasks.getModel().getRoot();
		setNodeExpandedState(node, expanded);
	}
	
	private void clearTextBoxError(int millis) {
		Timer t = new Timer(millis, new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                textBoxError.setText(null);
            }
        });
        t.setRepeats(false);
        t.start();
	}
	
	private void issueErrorMsg(String msg) {
		textBoxError.setText("Error: " + msg);
		log.error(msg);
		clearTextBoxError(20000);
	}
	
	private void issueWarningMsg(String msg) {
		textBoxError.setText("Warning: " + msg);
		log.warning(msg);
		clearTextBoxError(10000);
	}
	
	private void setChangesUnsaved() {
		changesSaved = false;
		labelUnsavedChanges.setText("There are unsaved changes");
		
		TaskManager tm = TaskManager.getInstance();
		if (!tm.getTaskFile().equals("")) {
			buttonOverwriteTasks.setEnabled(true);
			menuItem1_OverWriteTasks.setEnabled(true);
		}
	}
	
	private void setChangesSaved() {
		changesSaved = true;
		labelUnsavedChanges.setText("");
		buttonOverwriteTasks.setEnabled(false);
		menuItem1_OverWriteTasks.setEnabled(false);
	}
	private boolean areChangesSaved() { return changesSaved; }
	
	private void updateAuthor(String n) {
		authorName = n;
		labelAuthor.setText(authorName);
		log.info("Author name changed to: '" + authorName + "'.");
	}
	private String getAuthorName() { return authorName == null ? "??" : authorName; }
	private String requestAuthorName() {
		return JOptionPane.showInputDialog(this, "Enter the author's name:");
	}
	private void updateAuthorNameIfNone() {
		String n = requestAuthorName();
		if (n == null) {
			issueWarningMsg("Author name has not been set.");
		}
		else {
			updateAuthor(n);
		}
	}
	private void setNewAuthor() {
		authorName = requestAuthorName();
		updateAuthor(authorName);
	}
	
	private void overwriteChanges() {
		log.info("Saving tasks to disk");
		TaskManager tm = TaskManager.getInstance();
		tm.writeTasks(true); // do a backup
		log.info("Tasks created/edited so far have been saved to disk");
		setChangesSaved();
		// there is no need to manipulate the log files
	}
	
	private void openFile() {
		if (!areChangesSaved()) {
			promptSaveChanges();
		}
		
		// choose file
		log.info("Choosing file for opening...");
		JFileChooser fc = new JFileChooser();
		File file;
		int returnVal = fc.showOpenDialog(jPanel3);
        if (returnVal != JFileChooser.APPROVE_OPTION) {
            log.info("Open command cancelled by user.");
			return;
        }
		file = fc.getSelectedFile();
		String newFileName = file.getAbsolutePath();
		
		// make sure the file chosen is not locked
		log.info("Checking whether file '" + newFileName + "' is locked...");
		if (Tools.fileExists(Tools.getLockFileName(newFileName))) {
			issueErrorMsg("The file '" + newFileName + "' is locked!");
			return;
		}
		log.info("    File is not locked.");
		
		TaskManager tm = TaskManager.getInstance();
		
		// do more work only if the file being opened
		// is different from the one we opened before
		if (tm.getTaskFile().equals(newFileName)) {
			log.warning("Trying to open the file you had already opened. Duh!");
			return;
		}
		
		// close the current lock file and open a new one
		deleteLockFile();
		openLockFile(newFileName);
		
		// read the chosen file
		log.info("Opening file '" + newFileName + "'.");
		tm.setTaskFile(newFileName);
		if (!tm.readTasks()) {
			issueErrorMsg("Could not open selected file '" + newFileName + "'.");
			return;
		}
		
		// clear tree...
		highPriorNode.removeAllChildren();
		medPriorNode.removeAllChildren();
		lowPriorNode.removeAllChildren();
		treeModel.reload();
		
		// fill tree...
		tm.getHighPriorTasks().forEach((t) -> { taskToNode(highPriorNode, t); });
		tm.getMedPriorTasks().forEach((t) -> { taskToNode(medPriorNode, t); });
		tm.getLowPriorTasks().forEach((t) -> { taskToNode(lowPriorNode, t); });
		treeModel.reload();
		// clear the text boxes
		clearBoxesTask();
		// expand the tree
		setTreeExpandedState(true);
		// technically, there are no changes so...
		setChangesSaved();
	}
	
	private void saveChangesAs() {
		// choose file
		log.info("Choosing file for saving...");
		JFileChooser fc = new JFileChooser();
		File file;
		int returnVal = fc.showSaveDialog(jPanel3);
        if (returnVal != JFileChooser.APPROVE_OPTION) {
            log.info("Save command cancelled by user");
			return;
        }
		file = fc.getSelectedFile();
		String newFileName = file.getAbsolutePath();
		buttonOverwriteTasks.setEnabled(true);
		
		TaskManager tm = TaskManager.getInstance();
		
		// save task
		log.info("Saving to file '" + newFileName + "'");
		boolean do_backup = true; // backup the currently opened file if necessary
		if (!tm.getTaskFile().equals(newFileName)) {
			// if the file is different, open and close lock file
			deleteLockFile();
			openLockFile(newFileName);
			
			// if the new file is different there
			// is no need to do a backup...
			do_backup = false;
			tm.setTaskFile(newFileName);
		}
		tm.writeTasks(do_backup);
		setChangesSaved();
	}
	
	// assuming there are unsaved changes...
	private void promptSaveChanges() {
		String task_file = TaskManager.getInstance().getTaskFile();
		boolean save_as = false;
		if (task_file.equals("")) {
			log.info("There are unsaved changes that need to be stored in a file");
			save_as = true;
		}
		
		int response = JOptionPane.showConfirmDialog(
			null, "Do you want to save the changes?", "There are unsaved changes",
			JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE
		);
		
		boolean save = true;
		switch (response) {
			case JOptionPane.NO_OPTION:
			case JOptionPane.CLOSED_OPTION:
				save = false;
		}
		if (!save) {
			log.info("User does not want to save changes.... It's up to them...");
			return;
		}
		
		log.info("User wants to save changes");
		if (save_as) {
			log.info("Need a file");
			saveChangesAs();
			return;
		}
		overwriteChanges();
	}
	
	private String getPriority(DefaultMutableTreeNode n) {
		if (highPriorNode.isNodeDescendant(n)) { return "high"; }
		else if (medPriorNode.isNodeDescendant(n)) { return "med"; }
		else if (lowPriorNode.isNodeDescendant(n)) { return "low"; }
		issueErrorMsg("Could not determine priority of node");
		return "?";
	}
	
	private void refreshBoxesTask(Task t) {
		textBoxTaskName.setText(t.getName());
		textBoxTaskAuthor.setText(t.getCreator());
		labelTaskID.setText(t.getId());
		labelTaskState.setText(t.currentState().getState().toString());
		textBoxTaskDate.setText(t.getPrettyDate());
		textAreaTaskDescription.setText(t.getDescription());
		textAreaTaskChanges.setText(t.changesToString());
	}
	
	private void clearBoxesTask() {
		textAreaTaskDescription.setText("");
		labelTaskID.setText("000000");
		labelTaskState.setText("-");
		textAreaTaskChanges.setText("");
		textBoxTaskName.setText("");
		textBoxTaskDate.setText("");
	}
	
	private boolean treeHasSelection(String msg) {
		if (treeTasks.getSelectionCount() == 0) {
			issueErrorMsg(msg);
			return false;
		}
		return true;
	}
	
	private boolean treeHasSelection() {
		return treeTasks.getSelectionCount() > 0;
	}
	
    private void buttonClearMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonClearMouseClicked
        clearBoxesTask();
    }//GEN-LAST:event_buttonClearMouseClicked
	
    private void treeTasksValueChanged(TreeSelectionEvent evt) {//GEN-FIRST:event_treeTasksValueChanged
        if (!treeHasSelection()) { return; }
		DefaultMutableTreeNode sel
			= (DefaultMutableTreeNode) treeTasks.getLastSelectedPathComponent();
		if (sel.getLevel() <= 1) {
			// clear text boxes (nothing selected so nothing to show)
			clearBoxesTask();
			// disable edit button
			buttonEditTask.setEnabled(false);
			return;
		}
		Task node_task = (Task) sel.getUserObject();
		// fill in the text boxes
		refreshBoxesTask(node_task);
		// enable edit button
		buttonEditTask.setEnabled(true);
    }//GEN-LAST:event_treeTasksValueChanged

    private void buttonRemoveTaskMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonRemoveTaskMouseClicked
		if (!treeHasSelection("A task must be selected in order to delete it")) { return; }
		
		DefaultMutableTreeNode sel
			= (DefaultMutableTreeNode) treeTasks.getLastSelectedPathComponent();
		if (sel.getLevel() <= 1) {
			issueWarningMsg("You can't delete the root node or the high/med/low nodes");
			return;
		}
		
		TaskManager tm = TaskManager.getInstance();
		Task node_task = (Task) sel.getUserObject();
		boolean d = tm.deleteTask(node_task.getId());
		if (!d) {
			log.info("Attempted at removing a subtask from the task manager");
			log.info("    Subtasks are never added at the manager");
		}
		
		DefaultMutableTreeNode par_sel
			= (DefaultMutableTreeNode) treeTasks.getLastSelectedPathComponent();
		treeModel.removeNodeFromParent(sel);
		treeModel.reload(par_sel);
		setChangesUnsaved();
    }//GEN-LAST:event_buttonRemoveTaskMouseClicked

    private void buttonNewTaskMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonNewTaskMouseClicked
        if (treeTasks.getSelectionCount() == 0) {
			issueWarningMsg("A task can't be added if no category/task is selected.");
			return;
		}
		
		// prompt the user with an interface
		GUINewTask makeTask = new GUINewTask();
		makeTask.setTaskCreator(getAuthorName());
		Object[] button_options = {"Create task", "Cancel"};
		int res = JOptionPane.showOptionDialog(
			null, makeTask,
			"Create a new task",
			JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE,
			null, button_options, null
		);
		if (res != JOptionPane.OK_OPTION) {
			log.info("User cancelled creation of new task.");
			return;
		}
		
		// get data used to identify the task
		String taskName = makeTask.getTaskName();
		String taskCreator = makeTask.getTaskCreator();
		String taskDescr = makeTask.getTaskDescription();
		
		log.info("New task:");
		log.info("    Name: " + taskName + ".");
		log.info("    Creator: " + taskCreator + ".");
		log.info("    Description: " + taskDescr + ".");
		
		// find out if the task is high/med/low
		DefaultMutableTreeNode sel
			= (DefaultMutableTreeNode) treeTasks.getLastSelectedPathComponent();
		
		if (taskName.equals("")) {
			taskName = "Nameless task";
			log.info("No name for new task.");
		}
		if (taskDescr.equals("")) {
			taskDescr = "Empty task (yay! nothing to do!)";
			log.info("No description for new task.");
		}
		
		// create the task
		TaskManager tm = TaskManager.getInstance();
		Task new_t = tm.newTask(taskCreator, taskName, taskDescr);
		
		// the task should only be added to the taks manager's
		// containers if they are children of the "high/med/low" nodes.
		if (sel.getLevel() == 1) {
			String prior = getPriority(sel);
			if (prior.equals("high")) { tm.insertHighTask(0, new_t); }
			else if (prior.equals("med")) { tm.insertMedTask(0, new_t); }
			else if (prior.equals("low")) { tm.insertLowTask(0, new_t); }
			else { return; }
		}
		
		// is this new task a subtask? the selection is a task,
		// so the new task is actually a subtask!
		if (sel.getLevel() > 1) {
			// the task associated to the selected node
			Task node_task = (Task) sel.getUserObject();
			// add the new task as a subtask
			node_task.addSubtask(new_t);
			// change state
			String m = "A subtask was added (id: " + new_t.getId() + ")";
			node_task.changeState(taskCreator, m, TaskStateEnum.AddedSubtask);
			// fill in the text boxes
			refreshBoxesTask(node_task);
		}
		
		// make the node so as to show it to the user
		DefaultMutableTreeNode new_node = new DefaultMutableTreeNode(new_t);
		sel.insert(new_node, 0);
		treeModel.reload(sel);
		treeTasks.expandPath(new TreePath(sel.getPath()));
		treeTasks.setSelectionPath(new TreePath(new_node.getPath()));
		setChangesUnsaved();
    }//GEN-LAST:event_buttonNewTaskMouseClicked

	private void moveTaskUpDown(String dir, int incr) {
		if (!treeHasSelection("A task must be selected in order to move it")) { return; }
		DefaultMutableTreeNode sel
			= (DefaultMutableTreeNode) treeTasks.getLastSelectedPathComponent();
		if (sel.getLevel() <= 1) {
			issueWarningMsg("Can't move root node or nodes high/med/low.");
			return;
		}
		
		// the task associated to the node
		Task t = (Task) sel.getUserObject();
		
		log.info("Selected node (task id: '" + t.getId() + "' has level " + sel.getLevel() + ".");
		log.info("    Moving selection '" + dir + "' (by " + incr + ").");
		
		DefaultMutableTreeNode par_sel = (DefaultMutableTreeNode) sel.getParent();
		int idx = par_sel.getIndex(sel);
		if (dir.equals("up") && idx == 0) {
			issueWarningMsg("Can't increase priority of the highest-priority subtask.");
			return;
		}
		if (dir.equals("down") && idx == par_sel.getChildCount() - 1) {
			issueWarningMsg("Can't decrease priority of the lowest-priority subtask.");
			return;
		}
		
		log.info("    Selected node is the " + idx + "-th child of its parent.");
		
		// move the task inside the task manager
		if (sel.getLevel() == 2) {
			String prior = getPriority(sel);
			log.info("    Moving task of priority '" + prior + "' within the task manager.");
			TaskManager tm = TaskManager.getInstance();
			int i;
			if (prior.equals("high")) {
				i = tm.deleteHighTask(t.getId());
				tm.insertHighTask(i + incr, t);
			}
			else if (prior.equals("med")) {
				i = tm.deleteMedTask(t.getId());
				tm.insertMedTask(i + incr, t);
			}
			else if (prior.equals("low")) {
				i = tm.deleteLowTask(t.getId());
				tm.insertLowTask(i + incr, t);
			}
			else { return; }
			log.info("    Moved from position " + (i) + " to position " + (i + incr) + ".");
		}
		
		// if the task has a parent, move the subtask
		// within the parent's list of subtasks
		Task parent_task = t.getParentTask();
		if (parent_task != null) {
			log.info("    Moving task within the parent task's list of subtasks.");
			parent_task.moveSubtaskBy(t.getId(), incr);
		}
		
		// move the task in the tree
		treeModel.removeNodeFromParent(sel);
		par_sel.insert(sel, idx + incr);
		
		sel = (DefaultMutableTreeNode) par_sel.getChildAt(idx + incr);
		treeModel.reload(par_sel);
		treeTasks.expandPath(new TreePath(sel.getPath()));
		treeTasks.setSelectionPath(new TreePath(sel.getPath()));
		setChangesUnsaved();
	}
	
    private void buttonTaskUpMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonTaskUpMouseClicked
        moveTaskUpDown("up", -1);
    }//GEN-LAST:event_buttonTaskUpMouseClicked

    private void buttonTaskDownMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonTaskDownMouseClicked
        moveTaskUpDown("down", +1);
    }//GEN-LAST:event_buttonTaskDownMouseClicked

	private void changeTaskPriority(String dir, int incr) {
		if (!treeHasSelection("A task must be selected in order to move it")) {
			return;
		}
		updateAuthorNameIfNone();
		
		DefaultMutableTreeNode sel
			= (DefaultMutableTreeNode) treeTasks.getLastSelectedPathComponent();
		if (sel.getLevel() < 0) { return; }
		if (sel.getLevel() <= 1) {
			issueWarningMsg("Can't move root node or nodes high/med/low.");
			return;
		}
		if (sel.getLevel() > 2) {
			issueWarningMsg("Can't change a task's priority if it is a subtask of another task.");
			return;
		}
		
		String cur_prior = getPriority(sel);
		if (dir.equals("incr") && cur_prior.equals("high")) {
			issueWarningMsg("Can't increase priority of a highest-priority task.");
			return;
		}
		if (dir.equals("decr") && cur_prior.equals("low")) {
			issueWarningMsg("Can't decrease priority of a lowest-priority task.");
			return;
		}
		
		Task t = (Task) sel.getUserObject();
		TaskManager tm = TaskManager.getInstance();
		
		DefaultMutableTreeNode from_prior = null;
		DefaultMutableTreeNode to_prior = null;
		String verb = "";
		String new_prior = "??";
		
		if (cur_prior.equals("high")) {
			from_prior = highPriorNode;
			to_prior = medPriorNode;
			new_prior = "med";
			verb = "Decreased";
		}
		else if (cur_prior.equals("med")) {
			from_prior = medPriorNode;
			if (dir.equals("incr")) {
				to_prior = highPriorNode;
				new_prior = "high";
				verb = "Increased";
			}
			else if (dir.equals("decr")) {
				to_prior = lowPriorNode;
				new_prior = "low";
				verb = "Decreased";
			}
		}
		else if (cur_prior.equals("low")) {
			from_prior = lowPriorNode;
			to_prior = medPriorNode;
			new_prior = "medium";
			verb = "Increased";
		}
		else { return; }
		
		from_prior.remove(sel);
		to_prior.insert(sel, 0);
		
		if (cur_prior.equals("high"))     { tm.deleteHighTask(t.getId()); }
		else if (cur_prior.equals("med")) { tm.deleteMedTask(t.getId()); }
		else if (cur_prior.equals("low")) { tm.deleteLowTask(t.getId()); }
		
		if (new_prior.equals("high"))     { tm.insertHighTask(0, t); }
		else if (new_prior.equals("med")) { tm.insertMedTask(0, t); }
		else if (new_prior.equals("low")) { tm.insertLowTask(0, t); }
		
		t.changeState(
			getAuthorName(),
			verb + " priority to " + new_prior + ".",
			TaskStateEnum.PriorityChanged
		);
		
		refreshBoxesTask(t);
		treeModel.reload(from_prior);
		treeModel.reload(to_prior);
		treeTasks.expandPath(new TreePath(from_prior.getPath()));
		treeTasks.expandPath(new TreePath(to_prior.getPath()));
		treeTasks.expandPath(new TreePath(sel.getPath()));
		treeTasks.setSelectionPath(new TreePath(sel.getPath()));
		setChangesUnsaved();
	}
	
    private void buttonIncrPriorityMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonIncrPriorityMouseClicked
        changeTaskPriority("incr", -1);
    }//GEN-LAST:event_buttonIncrPriorityMouseClicked

    private void buttonDecrPriorityMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonDecrPriorityMouseClicked
        changeTaskPriority("decr", +1);
    }//GEN-LAST:event_buttonDecrPriorityMouseClicked

	// 'n' is the parent of task 't'
	private void taskToNode(DefaultMutableTreeNode n, Task t) {
		// make a new node, with associated task
		DefaultMutableTreeNode new_node = new DefaultMutableTreeNode(t);
		// insert node
		n.insert(new_node, n.getChildCount());
		// insert subtasks
		t.getSubtasks().forEach((st) -> { taskToNode(new_node, st); });
	}
	
    private void menuItem1_OpenFileMousePressed(MouseEvent evt) {//GEN-FIRST:event_menuItem1_OpenFileMousePressed
		openFile();
    }//GEN-LAST:event_menuItem1_OpenFileMousePressed

    private void buttonEditTaskMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonEditTaskMouseClicked
        if (!treeHasSelection("A task must be selected in order to edit its name and description.")) {
			return;
		}
		
		DefaultMutableTreeNode sel
			= (DefaultMutableTreeNode) treeTasks.getLastSelectedPathComponent();
		
		if (sel.getLevel() == 1) {
			issueErrorMsg("The selection must be a task (not a priority list)!");
			return;
		}
		
		Task t = (Task) sel.getUserObject();
		// current task's name and description
		String prevName = t.getName();
		String prevDescr = t.getDescription();
		
		// prompt the user with an interface
		GUINewTask editTask = new GUINewTask();
		editTask.setTaskName(prevName);
		editTask.setTaskCreator(getAuthorName());
		editTask.setTaskDescription(prevDescr);
		Object[] button_options = {"Save edits", "Cancel"};
		int res = JOptionPane.showOptionDialog(
			null, editTask,
			"Edit an already exiting task",
			JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE,
			null, button_options, null
		);
		if (res != JOptionPane.OK_OPTION) {
			log.info("User cancelled edition of task.");
			return;
		}

		// new name and description
		t.setName(editTask.getTaskName());
		t.setDescription(editTask.getTaskDescription());
		// set the change to the task
		t.taskWasEdited(
			editTask.getTaskCreator(), null,
			prevName, prevDescr, TaskStateEnum.Edited
		);
		
		refreshBoxesTask(t);
		
		// this edit jhas been written to the task, but not to the file
		setChangesUnsaved();
    }//GEN-LAST:event_buttonEditTaskMouseClicked

	/**
	 * Change a task's state.
	 * @param s The change of state of the task.
	 * @param use_reason Should I prompt the user for a reason?
	 */
	private void changeTaskState(TaskStateEnum s, boolean promptUser)
	{
		if (!treeHasSelection("A task must be selected in order to change its state")) {
			return;
		}
		updateAuthorNameIfNone();
		
		DefaultMutableTreeNode sel
			= (DefaultMutableTreeNode) treeTasks.getLastSelectedPathComponent();
		Task t = (Task) sel.getUserObject();
		String r = t.askChangeState(s);
		if (!r.equals("")) {
			issueErrorMsg("Can't change state of task (id: " + t.getId() + ") due to: " + r);
			return;
		}
		String reason = null;
		if (promptUser) {
			reason = JOptionPane.showInputDialog(
				null, "Why do you want to change the task's state?", "Change a task's state",
				JOptionPane.PLAIN_MESSAGE // no icon
			);
		}
		t.changeState(getAuthorName(), reason, s);
		refreshBoxesTask(t);
		treeModel.reload(sel);
		setChangesUnsaved();
	}
	
    private void buttonTaskDoneMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonTaskDoneMouseClicked
        changeTaskState(TaskStateEnum.Done, false);
    }//GEN-LAST:event_buttonTaskDoneMouseClicked

    private void buttonTaskWorkingMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonTaskWorkingMouseClicked
        changeTaskState(TaskStateEnum.Working, false);
    }//GEN-LAST:event_buttonTaskWorkingMouseClicked

    private void buttonTaskHoldMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonTaskHoldMouseClicked
        changeTaskState(TaskStateEnum.PutOnHold, true);
    }//GEN-LAST:event_buttonTaskHoldMouseClicked

    private void buttonTaskOnRevisionMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonTaskOnRevisionMouseClicked
        changeTaskState(TaskStateEnum.OnRevision, false);
    }//GEN-LAST:event_buttonTaskOnRevisionMouseClicked

    private void buttonTaskPendingRevisionMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonTaskPendingRevisionMouseClicked
        changeTaskState(TaskStateEnum.PendingRevision, true);
    }//GEN-LAST:event_buttonTaskPendingRevisionMouseClicked

    private void buttonTaskCancelMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonTaskCancelMouseClicked
        changeTaskState(TaskStateEnum.Cancelled, true);
    }//GEN-LAST:event_buttonTaskCancelMouseClicked

    private void buttonTaskDeleteMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonTaskDeleteMouseClicked
        changeTaskState(TaskStateEnum.Deleted, true);
    }//GEN-LAST:event_buttonTaskDeleteMouseClicked

    private void menuItem2_AboutMousePressed(MouseEvent evt) {//GEN-FIRST:event_menuItem2_AboutMousePressed
        GUIAbout paneAbout = new GUIAbout();
		JDialog dialogAbout = new JDialog(this, "About");
		dialogAbout.add(paneAbout);
		dialogAbout.setSize(750, 570);
		dialogAbout.setResizable(false);
		dialogAbout.setVisible(true);
		
    }//GEN-LAST:event_menuItem2_AboutMousePressed

    private void buttonExpandAllMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonExpandAllMouseClicked
        setTreeExpandedState(true);
    }//GEN-LAST:event_buttonExpandAllMouseClicked

    private void buttonContractAllMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonContractAllMouseClicked
        setTreeExpandedState(false);
    }//GEN-LAST:event_buttonContractAllMouseClicked

    private void formWindowClosing(WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        if (!areChangesSaved()) {
			promptSaveChanges();
		}
		deleteLockFile();
		log.info("Closing TodoListManager...");
		log.end();
    }//GEN-LAST:event_formWindowClosing

    private void menuItem1_ExitMousePressed(MouseEvent evt) {//GEN-FIRST:event_menuItem1_ExitMousePressed
		dispatchEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));
    }//GEN-LAST:event_menuItem1_ExitMousePressed

    private void buttonSaveTasksAsMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonSaveTasksAsMouseClicked
        saveChangesAs();
    }//GEN-LAST:event_buttonSaveTasksAsMouseClicked

    private void buttonOverwriteTasksMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonOverwriteTasksMouseClicked
        if (buttonOverwriteTasks.isEnabled()) {
			overwriteChanges();
		}
    }//GEN-LAST:event_buttonOverwriteTasksMouseClicked

    private void buttonOpenTasksMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonOpenTasksMouseClicked
        openFile();
    }//GEN-LAST:event_buttonOpenTasksMouseClicked

    private void menuItem1_SaveTasksAsMouseClicked(MouseEvent evt) {//GEN-FIRST:event_menuItem1_SaveTasksAsMouseClicked
        if (menuItem1_SaveTasksAs.isEnabled()) {
			saveChangesAs();
		}
    }//GEN-LAST:event_menuItem1_SaveTasksAsMouseClicked

    private void menuItem1_OverWriteTasksMouseClicked(MouseEvent evt) {//GEN-FIRST:event_menuItem1_OverWriteTasksMouseClicked
		if (menuItem1_OverWriteTasks.isEnabled()) {
			overwriteChanges();
		}
    }//GEN-LAST:event_menuItem1_OverWriteTasksMouseClicked

    private void buttonSetAuthorMouseClicked(MouseEvent evt) {//GEN-FIRST:event_buttonSetAuthorMouseClicked
		setNewAuthor();
    }//GEN-LAST:event_buttonSetAuthorMouseClicked

	/**
	 * @param args the command line arguments
	 */
	public static void main(String args[]) {
		/* Set the Nimbus look and feel */
		//<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
		/* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
		 */
		try {
			for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
				if ("Nimbus".equals(info.getName())) {
					javax.swing.UIManager.setLookAndFeel(info.getClassName());
					break;
				}
			}
		} catch (ClassNotFoundException ex) {
			java.util.logging.Logger.getLogger(MainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
		} catch (InstantiationException ex) {
			java.util.logging.Logger.getLogger(MainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
		} catch (IllegalAccessException ex) {
			java.util.logging.Logger.getLogger(MainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
		} catch (javax.swing.UnsupportedLookAndFeelException ex) {
			java.util.logging.Logger.getLogger(MainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
		}
		//</editor-fold>

		/* Create and display the form */
		java.awt.EventQueue.invokeLater(new Runnable() {
			public void run() {
				new MainView().setVisible(true);
			}
		});
	}

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private JButton buttonClear;
    private JButton buttonContractAll;
    private JButton buttonDecrPriority;
    private JButton buttonEditTask;
    private JButton buttonExpandAll;
    private JButton buttonIncrPriority;
    private JButton buttonNewTask;
    private JButton buttonOpenTasks;
    private JButton buttonOverwriteTasks;
    private JButton buttonRemoveTask;
    private JButton buttonSaveTasksAs;
    private JButton buttonSetAuthor;
    private JButton buttonTaskCancel;
    private JButton buttonTaskDelete;
    private JButton buttonTaskDone;
    private JButton buttonTaskDown;
    private JButton buttonTaskHold;
    private JButton buttonTaskOnRevision;
    private JButton buttonTaskPendingRevision;
    private JButton buttonTaskUp;
    private JButton buttonTaskWorking;
    private Box.Filler filler1;
    private JLabel jLabel1;
    private JLabel jLabel2;
    private JLabel jLabel3;
    private JLabel jLabel4;
    private JLabel jLabel5;
    private JLabel jLabel6;
    private JLabel jLabel7;
    private JMenu jMenu1;
    private JMenu jMenu2;
    private JMenuBar jMenuBar1;
    private JPanel jPanel1;
    private JPanel jPanel2;
    private JPanel jPanel3;
    private JPanel jPanel5;
    private JPanel jPanel7;
    private JScrollPane jScrollPane1;
    private JScrollPane jScrollPane6;
    private JScrollPane jScrollPane7;
    private JPopupMenu.Separator jSeparator1;
    private JToolBar.Separator jSeparator2;
    private JToolBar.Separator jSeparator3;
    private JToolBar jToolBar1;
    private JLabel labelAuthor;
    private JLabel labelTaskID;
    private JLabel labelTaskState;
    private JLabel labelUnsavedChanges;
    private JMenuItem menuItem1_Exit;
    private JMenuItem menuItem1_OpenFile;
    private JMenuItem menuItem1_OverWriteTasks;
    private JMenuItem menuItem1_SaveTasksAs;
    private JMenuItem menuItem2_About;
    private JTextArea textAreaTaskChanges;
    private JTextArea textAreaTaskDescription;
    private JTextField textBoxError;
    private JTextField textBoxTaskAuthor;
    private JTextField textBoxTaskDate;
    private JTextField textBoxTaskName;
    private JTree treeTasks;
    // End of variables declaration//GEN-END:variables

}
